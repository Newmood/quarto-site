---
title: "Stateless Protocol, Stateful Needs"
title-block-banner: true
description: How session management is done in websites so users receive the desired experience. This post does not talk about implementations or provide code snippets, studies client side storage in detail with example case.
categories:
  - Computer Science
date: "2025-05-14"
bibliography: ref.bib
format:
  html:
    toc: true
    toc-depth : 4
    toc-expand: 3
    number-sections: true
---

## Introduction
Consider a user engages with an e-commerce application. The user logins with their credentials, then add something to the cart, scrolls around a bit - sees a section that shows previously browsed items and finally concludes by logging out (or maybe just closing the browser). Now when they login again later, they see the item is still there in the cart.

HTTP by itself is a stateless protocol, meaning each request is a fresh new connection between server and client. Then how do the sites know whether a user is logged in and has objects in the cart? In other words, how does server know the state of the user during a session? Thankfully there are workarounds to provide for the stateful needs using the stateless protocol.

## Sessions
> A session is a long running interaction between a client and a server. It may consist of a single request, but more commonly it consists of a series of requests that the user regards as a consistent logical sequence.

A site has to keep record of these sessions and we will see how these sessions are stored and used to deliver the content to the user. Somehow, we have to make the app aware of whatever the user is doing during the session or has done previously. Now, this means with each HTTP request we have to send and receive a lot of data but with proper session management this reduces to sending a small session ID/token that helps retrieve the associated data. A session may initialise, modify a lot data objects for a user and we can tie this to a session ID for session management.

There are two ways to store the session state:

1. Client session state
2. Server session state

It is to note that database session state is mostly included in server session state however, @fowlerpeaa recognised it as a separate category. Regardless of the method used, typically a session ID is transferred back and forth with HTTP requests in the form of **session cookie**. This cookie is stored in the client side. 

### Client Session State
As evident by name, this stores the data on the client. In some cases, it is possible to keep all session data on client and with each request this entire set of data is sent back and forth between server and the client. This can be done using : URL parameters, hidden fields/forms and cookies.

#### URL Paramters
Example : `somesite.com?id=87654321`  
This is easy for small amout of data and if security is not a concern. While, keeping on adding more data increases the URL length, which is mostly not desirable. Also, URL rewriting may cause problems with bookmarks in client side.

#### Hidden Fields
This is done using the HTML tag `<INPUT type="hidden">` to store data within a form and submitting using `POST` request. Again this can be used if data is not sensitive, since this is visible and editable by client and has no encryption.

#### Cookies
Cookies are name-value pairs that are saved and managed by browsers. These are sent back and forth with HTTP header and only contains text strings, however complex objects can be serialized (convert from object ot string) into cookies. 

- Limitations : Cookies support limited amount of data (~4KB) and are tied to the domain (not the page), which means if an application spans multiple domain, the cookie will not carry over. 
- Expiration : HTTP cookies can expire, given how they're configured. If they are session cookies, they typically expire when the session closed (browser/tab is closed). On the other hand, if they are persistent cookies, the expiration time can be set using `Expires` and `Max-Age` tags.
- Security : Using `HttpOnly` attribute, the cookie can't be accessed by JavaScript which reduces risk of cross-site-scripting or XSS. The `Secure` tag helps mitigate man-in-the-middle attacks by ensuring cookies are only sent over HTTPS (`Secure` does not work with HTTP). There is a `SameSite` attribute controls whether cookies are sent with cross-site requests. By blocking cookies in cross-site scenarios it helps prevent CSRF attacks.

To understand how cookies work across sub-domains and how it implements `SameSite`, it is important to understand [origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) first.

#### Web Storage
There's mostly two types of session storage to work with - **session storage**, one that spans for a session and then expires and **persistent storage** which stays for much longer duration before expiring (as we have seen for cookies and more to come). Browsers offer a Web Storage API which allows for preserving non-essential state across requests and even session. Specifically this API offers two storage objects :   

- `localStorage` : This persists between browser session
- `sessionStorage` : This stores data that will be lost after browser session is over.

#### IndexedDB




### To write
- webstorageAPI (sessionstorage and persistentstorage), IndexedDB
- Cookie overhead is too much -store static files in separate domain.
- session data must be committed to become record data
- What if people tamper/delete or turn off cookies? Ideally site should be perfectly operational still; hence it is bad design to depend solely depend on cookies during implementation of features.
- Using cookies and caching some information.
- Bonus section : "Remember me?" - checkbox on login - persistent cookie usage. Chapter 17 Security in FWD

## References
---
nocite: |
  @connollyfwd
---

::: {#refs}
:::

- https://stytch.com/blog/localstorage-vs-sessionstorage-vs-cookies/